#+title: luckyone

**** 源码

#+BEGIN_SRC js

contract LuckyOne 
{
    address owner; 
    uint testluckyone;
    uint public numaddrs;
    uint public numwiners;
    event Log(address _from, address _to, string _func, string _msg, uint _value);
    //event GetBalance(uint _value);
    struct betinfo 
    {
        uint choice;
        uint value; 
    }
    mapping(address => betinfo) public betinfos; 
    mapping(uint => address) public addrs;
    mapping(uint => address) public winers;
    function LuckyOne() 
    {
        owner = msg.sender;
    }
    function kill()
    {
        if (msg.sender == owner)
            suicide(owner);
    }
    function getBalance() returns (uint) 
    {
        Log(msg.sender, 0, "getBalance()", "0", this.balance);
        return this.balance;
    }
    function adminWithdraw()
    {
        if (owner != msg.sender)
            return;
        msg.sender.send(this.balance);
    }
    function bet(uint choice) public
    {
        Log(msg.sender, 0, "bet()=>", "0", choice);
        Log(msg.sender, 0, "bet()=>", "0", msg.value);
        betinfos[msg.sender] = betinfo({choice: choice, value: msg.value});
        addrs[numaddrs++] = msg.sender;
    }
    function setlucky(uint num) public
    {
        if (owner != msg.sender)
            throw;
        Log(msg.sender, 0, "before setlucky()=>", "0", testluckyone);
        Log(msg.sender, 0, "after setlucky()=>", "0", num);
        testluckyone = num;
    }

    function getvalue(address client_addr) returns (uint) 
    {
        Log(msg.sender, 0, "getvalue()=>", "0", betinfos[client_addr].value);
        return betinfos[client_addr].value;
    }
    function getchoice(address client_addr) returns (uint) 
    {
        Log(msg.sender, 0, "getchoice()=>", "0", betinfos[client_addr].choice);
        return betinfos[client_addr].choice;
    }
    function lucky() returns (uint) 
    {
        if (owner != msg.sender)
            throw;
        var r = 0;
        for (var i = 0; i < numaddrs; i+=1)
        {
            if (betinfos[addrs[i]].choice == testluckyone)
            {
                winers[numwiners++] = addrs[i];
                r += 1;
                Log(msg.sender, 0, "lucky() winers:", "0", testluckyone);
            }
        }
        return r;
    }
}


#+END_SRC

**** 一些待定的问题
- 智能合约参数设定，一些有关游戏规则的动态变化如何来设定。
- 智能合约执行的时候检测，需要保存用户信息。如何来保存。
- 如何做到智能开奖，智能合约能否做到？假如有1万个用户下注，智能合约脚本可以获取到用户信息吗？
- 如何兑奖，涉及到多个帐户转帐。比如1万个帐户。
- 钱包的问题，一个用户在中心网站注册生成一个下注地址，涉及到如何通过程序创建钱包。以及钱包的管理问题。
- 闪电网络现在还没有成熟起来，后续我们如何用闪电网络的问题？
- 每一个用户下注的时候在智能合约里面就知道用户的Address地址，下了多少注，下注内容，这些信息都需要保存起来。如果用户量比较大的时候。这时候会不会有问题？
