#+TITLE: 比特币开发指南导读笔记

** Merkle树

1. [[http://blog.csdn.net/yuanrxdu/article/details/22474697?utm_source=tuicool&utm_medium=referral][Merkle Tree算法详解]]
2. [[http://www.jianshu.com/p/458e5890662f][白话 Merkle Tree]]


Merkle Tree是Dynamo中用来同步数据一致性的算法，Merkle Tree是基于数据HASH构建的一个树。它具有以下几个特点：

1. 数据结构是一个树，可以是二叉树，也可以是多叉树（本BLOG以二叉树来分析）
2. Merkle Tree的叶子节点的value是数据集合的单元数据或者单元数据HASH。
3. Merke Tree非叶子节点value是其所有子节点value的HASH值。

为了更好的理解，我们假设有A和B两台机器，A需要与B相同目录下有8个文件，文件分别是f1 f2 f3 ....f8。这个时候我们就可以通过Merkle Tree来进行快速比较。假设我们在文件创建的时候每个机器都构建了一个Merkle Tree。具体如下图:
[[file:./images/merkle_tree_01.jpg]]

从上图可得知，叶子节点node7的value = hash(f1),是f1文件的HASH;而其父亲节点node3的value = hash(v7, v8)，也就是其子节点node7 node8的值得HASH。就是这样表示一个层级运算关系。root节点的value其实是所有叶子节点的value的唯一特征。

假如A上的文件5与B上的不一样。我们怎么通过两个机器的merkle treee信息找到不相同的文件? 这个比较检索过程如下:

1. 首先比较v0是否相同,如果不同，检索其孩子node1和node2.
2. v1 相同，v2不同。检索node2的孩子node5 node6;
3. v5不同，v6相同，检索比较node5的孩子node 11 和node 12
4. v11不同，v12相同。node 11为叶子节点，获取其目录信息。
5. 检索比较完毕。

以上过程的理论复杂度是Log(N)。实际过程是大于这个复杂度的，因为不同value的节点需要每个子节点进行比较。过程描述图如下:

[[file:./images/merkle_tree_02.jpg]]

从上图可以得知真个过程可以很快的找到对应的不相同的文件。

如果A机器的目录下增加了一个文件f9。整个merkle tree就会变成这样的:

[[file:./images/merkle_tree_03.jpg]]

其中红色字体是需要进行运算的步骤，整个过程是从叶子节点发起的，直接回溯到root节点为止。

假如目录下的f1被删除。整树的运算变化图如下:

[[file:./images/merkle_tree_04.jpg]]

红色字体是需要进行的运算。


从上可以得知，merkle tree在大数据集合校验可以提高校验的效率的。从Dynamo论文中可以看出，大量使用merkle tree来同步分布式节点的文件和写操作，尤其是在服务节点异常后的情况，具体细节可以参看Dynamo论文中的描述。

** 白话 Merkle Tree
今天为啥又聊 Merkle Tree 呢？ 我们地球上大部分人应该连它的名字都没有听过，而且说实话它也是个比较传统的概念了。Merkle Tree 是由计算机科学家 Ralph Merkle 在很多年前提出的，并以他本人的名字来命名。不过，Merkle Tree 确实涉及到了很多有意思的实际应用。最近几年才有的一个例子是，比特币钱包服务用 Merkle Tree 的机制来作”百分百准备金证明“ （ http://blog.bifubao.com/2014/03/16/proof-of-reserves/ ）。不过今天，我们还是从数据的“完整性校验”这个角度来聊 Merkle Tree。 Git 版本控制系统，ZFS 文件系统以及我们自己下载电影常用的点对点网络 BT 下载，都是通过 Merkle Tree 来进行完整性校验的。顺便说一句，所谓的完整性校验，就是检查一下数据有没有损坏。

** 先说哈希( Hash )

其实要实现完整性校验，最简单的方法就是对要校验的整个的数据文件做个哈希运算，把得到的哈希值公布在网上，这样我们把数据下载到手之后，再次运算一下哈希值，如果运算结果相等，就表示我们下载过程中文件没有任何的损坏。因为哈希的最大特点是，如果你的输入数据，稍微变了一点点，那么经过哈希运算，你得到的哈希值将会变得面目全非。这样做的一个目的是可以防止有人根据哈希值反推出原始输入数据的一些特征。前面我录了一期视频专门关于哈希的，大家可以看看。

如果我们从一个稳定的服务器上进行下载，那么采用单个哈希来进行校验的形式是可以接受的。

** 再说哈希列表（ Hash List ）

但是在点对点网络中作数据传输的时候，我们会从同时从多个机器上下载数据，而且其中很多机器可以认为是不稳定或者是不可信的，这时需要有更加巧妙的做法。实际中，点对点网络在传输数据的时候，其实都是把比较大的一个文件，切成小的数据块。这样的好处是，如果有一个小块数据在传输过程中损坏了，那我只要重新下载这一个数据块就行了，不用重新下载整个文件。当然这就要求每个数据块都拥有自己的哈希值。BT 下载的时候，在下载真正的数据之前，我们会先下载一个哈希列表的。这时有一个问题就出现了，那么多的哈希，我们怎么保证它们本身都是正确地呢？

答案是我们需要一个根哈希。把每个小块的哈希值拼到一起，然后对整个这个长长的字符串再做一次哈希运算，最终的结果就是哈希列表的根哈希。于是，如果我们能够保证从一个绝对可信的网站，或者从我们的朋友手里拿到一个正确的根哈希，就可以用它来校验哈希列表中的每一
个哈希都是正确的，进而可以保证下载的每一个数据块的正确性了。

这种方式挺好，但是实际的应用中，其实还是有着它的不足之处的，这就是为什么 Merkle 教授要发明 Merkle Tree 了。


** 最后是 Merkle Tree

先看它的结构。

在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应地哈希和它对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希就结婚生子，得到了一个”子哈希“。如果最底层的哈希总数是单数，那到最后必然出现一个单身哈希，这种情况就直接对它进行哈希运算，所以也能得到它的子哈希。于是往上推，依然是一样的方式，可以得到数目更少的新一级哈希，最终必然形成一棵倒挂的树，到了树根的这个位置，这一代就剩下一个根哈希了，我们把它叫做 Merkle root.

再说它的优点。

相对于 Hash List，Merkle Tree 的明显的一个好处是可以单独拿出一个分支来（作为一个小树）对部分数据进行校验，这个很多使用场合就带来了哈希列表所不能比拟的方便和高效。

好，这一期就说这么多，大家现在概念上有个认识，后面我们会有专门的文章讲 Merkle Tree 实用的例子。



